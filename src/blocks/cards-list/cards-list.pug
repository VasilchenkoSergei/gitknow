include ../../blocks/main-card/main-card.pug

.cards-list
  +main-card('git init', 'создаёт в текущей директории новую поддиректорию с именем .git, содержащую все необходимые файлы репозитория — основу Git-репозитория.')
  +main-card('git clone', '', list = true)
    p.
      <b>git clone путьДоРепозитория</b> (например – git clone https://github.com/IvanIvanov/gitknow.git) – клонирует удаленный репозиторий на ваш компьютер. При выполнении команды в выбранной директории автоматически создастся новая директория с именем предшествующим, записанным между последним “/” и “.git”. Из примера выше создастся папка gitknow, в которой будет создана директория “.git”.  Если хотите задать другое имя директории, то его надо указать через пробел после всей команды – например, git clone https://github.com/IvanIvanov/gitknow.git новоеИмяДиректории
  +main-card('git status', '', pre = true)
    p.
      Информирует о проделанных операциях и их результатах
      Если не было никаких изменений, то выдаст следующее сообщение:<br>
      “On branch master<br>
      No commits yet<br>
      nothing to commit (create/copy files and use "git add" to track)”<br>
      <b>On branch master – указывает на ветку master;</b><br>
      <b>No commits yet – нет никаких коммитов;</b><br>
      <b>Nothing to commit (create/copy files and use "git add" to track) – нечего коммитить, отсутствуют файлы в принципе (предлагается их создать и проиндексировать);</b><br>
      Если были проделаны изменения где-либо в директории, тогда выдаст следующее сообщение:<br>
      “Untracked files:<br>
        (use "git add <file>..." to include in what will be committed)<br>
          new-file.pug<br>
      src/blocks/new-file-2.pug<br>
      nothing added to commit but untracked files present (use "git add" to track)”<br>
      <b>Untracked files – указывает на непроиндексированные файлы;</b><br>
      <b>use "git add <file>..." to include in what will be committed, nothing added to commit but untracked files present (use "git add" to track) – предлагает использовать команду git add для измененных файлов
      Если была проведена индексация, тогда выдаст следующее сообщение:</b><br>
      “Changes to be committed:<br>
        (use "git rm --cached <file>..." to unstage)<br>
          new file:   new.pug<br>
      src/blocks/new-file-2.pug”<br>

      Changes to be committed – изменения для коммита<br>
      use "git rm --cached <file>..." to unstage - 


  +main-card('git add', '', list = true)
    p.
      Индексирует изменения всех файлов, находящихся в локальной директории (другими словами просто фиксирует изменения). Например – <b>git add путьДоФайла</b> (путь до конкретного файла можно получить выполнив команду git status)
      Разновидности git add:
    ul
      li <b>git add .</b> – индексация всех файлов в текущей директории и во всех вложенных (точка по сути указывает путь). Обычно эта команда выполняется в базовой директории (там где расположена директория .git) Если перейти в любую вложенную директорию, и выполнить эту команду, то проиндексируются все файлы в этой директории и во всех вложенных. Изменения в других директориях так и останутся без индексации.
      li <b>git add :/</b> - индексация всех файлов в любой директории, вложенной в базовую (там где расположена директория .git), в том числе и в базовой. (git add -A и git add --all - аналогичны этой команде)

  +main-card('git reset', '', list = true)
    p.
      Отменяет индексацию измененных файло.
      Разновидности git reset:
    ul
      li <b>git reset --hard</b> удаляет все сделанные изменения и возвращает все к последнему коммиту.
      li <b>git reset --soft</b> возвращает к последнему коммиту, но не удаляет сделанные изменения.
      li <b>git reset номерКоммита</b> (например git reset 9e5e6a4) возвращает к соответствующему коммиту, а изменения сделанные после него сохраняются, но остаются непроиндексированные.
      li <b>git reset номерКоммита --hard</b> - удалит все изменения после данного коммита. Если вы удалили полностью все коммиты и локально и удаленно, то вернуться к старым коммитам еще можно. git log не покажет историю коммитов уже. А git reflog покажет. Нужно выбрать нужный коммит и сделать reset на его порядковый номер, например git reset --hard HEAD@{5}.
        
  +main-card('git log', '', list = true)
    p.
      Выводит список коммитов с полным их номером названием и указанием авторства и даты.<br><b>git log --pretty=oneline</b> выведет только номера коммитов и их названия
  +main-card('git reflog', 'выдает список всех коммитов с непосредственным номером коммита и его порядковым номер (например HEAD@{5})')
  +main-card('git commit', '', list = true)
    p.
      Выполняет коммит изменений. <b>git commit -m "названиеКоммита"</b> - сделать коммит проиндексированных файлов.
      Разновидности git commit:
    ul
      li <b>git commit -m "названиеКоммита"</b> - сделать коммит проиндексироваанных файлов.
      li <b>git commit -a -m "названиеКоммита"</b> - индексирует файлы и коммитит (позволяет обойтись без git add !НО не индексирует новые созданные файлы, а только измененные).
      li <b>git commit --amend -m "новоеНазваниеКоммита"</b> - переименовать последний сделанный коммит
  +main-card('git show', '', list = true)
    p.
      <b>git show номерКоммита</b> (например - git show 9e5e6a4) покажет какие изменения были внесены в этом коммите
  +main-card('git branch', '', list = true)
    p.
      Покажет все созданные ветки с указанием активной ветки.
      Разновидности git branch:
    ul
      li <b>git branch названиеНовойВетки</b> - создает новую ветку.
      li <b>git branch -m новоеНазваниеТекущейВетки</b> - смена названия ветки.
      li <b>git branch -d названиеВетки</b> - удаление ветки, при этом необходимо находиться на любой другой ветке, чтобы удаляемая не была текущей.
      
  +main-card('git grep', '', list = true)
    p.
      <b>git grep словоДляПоиска</b> - ищет указанное слово/фрагмент в проекте
  +main-card('git checkout', '', list = true)
    p.
      <b>git checkout названиеВетки</b> - переключает на указанную ветку. 
      Разновидности git checkout:
    ul
      li <b>git checkout -b названиеВетки</b> - создает ветку с указанным именем и сразу переходит в нее
  +main-card('git pull', '', list = true)
    p.
      Подтягивает изменения с удаленного репозитория. Находясь на нужной ветке подтянет то, чего нет с удаленной такой же ветки. Изменения отобразятся только в соответствующих ветках. <b>git pull origin названиеВетки</b> - подтянет изменения с указанной удаленной ветки в ту локальную, в которой вы сейчас находитесь
  +main-card('git remote', '<b>git remote -v</b> - покажет какой репозиторий привязан к проекту')
  +main-card('git revert', '', list = true)
    p.
      Отменяет проведенные изменения в конкретном коммите. При этом создает новый обычный коммит с обращенными назад изменениями указанного коммита. <b>git revert номерКоммита</b> (git revert 9e5e6a4) - найдет коммит и обратит его изменения. Но может возникнуть конфликт изменений, если обращенные изменения уже были модифицированы после коммита, к которому был применен revert.
      Разновидности git revert:
    ul
      li <b>git revert --abort</b> - отменяет команду revert
  +main-card('git push', '', list = true)
    p.
      Заливает все изменения со всех локальных веток в удаленный репозиторий. Ветки, созданные локально, но не существующие в репозитории, будут там автоматически созданы. Если это делаете первый раз в новом проекте, то скорее всего терминал вам выдаст сообщение об ошибке с предложением команды <b>git push --set-upstream origin названиеВетки</b>. Необходимо ее выполнить один раз, чтобы связать удаленный репозиторий с вашим проектом. Дальше можно будет уже использовать только git push. Если на удаленном репозитории появились изменения, которых у вас нет локально, то при попытке пуша возникнет ошибка-предупреждение. Она предлагает вам подтянуть новые изменения через git pull, а уже потом выполнить git push. To https://github.com/VasilchenkoSergei/gitknow.git
      ! [rejected] master -> master (fetch first)
      error: failed to push some refs to 'https://github.com/VasilchenkoSergei/gitknow.git'hint: Updates were rejected because the remote contains work that you do
      hint: not have locally. This is usually caused by another repository pushing
      hint: to the same ref. You may want to first integrate the remote changes
      hint: (e.g., 'git pull ...') before pushing again.
      hint: See the 'Note about fast-forwards' in 'git push --help' for details.
      Разновидности git push:
    ul
      li <b>git push --force(или git push -f)</b> - заливает на удаленный репозиторий в любом случае (но при этом нужно убедиться, что вы не затрете изменения, которые кто-то внес до вашего пуша)
  +main-card('git merge', '', list = true)
    p.
      Выполняет слияние одной ветки в другую. <b>git merge названиеВетки</b> (например git merge develop) - находясь на любой другой ветке, вы будете вливать ветку develop в ту, на которой находитесь.
      Разновидности git merge:
    ul
      li <b>git merge --abort</b> - отменяет слияние веток при возникшем конфликте (не работает если слияние прошло успешно)
include ../../blocks/main-card/main-card.pug

.cards-list
  +main-card('git init', 'создаёт в текущей директории новую поддиректорию с именем .git, содержащую все необходимые файлы репозитория — основу Git-репозитория.')
  +main-card('git clone', 'git clone путьДоРепозитория (например – git clone https://github.com/IvanIvanov/gitknow.git) – клонирует удаленный репозиторий на ваш компьютер. При выполнении команды в выбранной директории автоматически создастся новая директория с именем предшествующим, записанным между последним “/” и “.git”. Из примера выше создастся папка gitknow, в которой будет создана директория “.git”.  Если хотите задать другое имя директории, то его надо указать через пробел после всей команды – например, git clone https://github.com/IvanIvanov/gitknow.git новоеИмяДиректории')
  +main-card('git status', '', pre = true)
    p.
      информирует о проделанных операциях и их результатах
      Если не было никаких изменений, то выдаст следующее сообщение:
      “On branch master
      No commits yet
      nothing to commit (create/copy files and use "git add" to track)”
      On branch master – указывает на ветку master
      No commits yet – нет никаких коммитов
      Nothing to commit (create/copy files and use "git add" to track) – нечего коммитить, отсутствуют файлы в принципе (предлагается их создать и проиндексировать)
      Если были проделаны изменения где-либо в директории, тогда выдаст следующее сообщение:
      “Untracked files:
        (use "git add <file>..." to include in what will be committed)
              new-file.pug
      src/blocks/new-file-2.pug
      nothing added to commit but untracked files present (use "git add" to track)”
      Untracked files – указывает на непроиндексированные файлы
      use "git add <file>..." to include in what will be committed, nothing added to commit but untracked files present (use "git add" to track) – предлагает использовать команду git add для измененных файлов
      Если была проведена индексация, тогда выдаст следующее сообщение:
      “Changes to be committed:
        (use "git rm --cached <file>..." to unstage)
              new file:   new.pug
      src/blocks/new-file-2.pug”

      Changes to be committed – изменения для коммита
      use "git rm --cached <file>..." to unstage - 


  +main-card('git add', '', list = true)
    p.
      индексирует изменения всех файлов, находящихся в локальной директории (другими словами просто фиксирует изменения)
      например – git add путьДоФайла (путь до конкретного файла можно получить выполнив команду git status)
      Разновидности git add:
    ul
      li git add . – индексация всех файлов в текущей директории и во всех вложенных (точка по сути указывает путь). Обычно эта команда выполняется в базовой директории (там где расположена директория .git) Если перейти в любую вложенную директорию, и выполнить эту команду, то проиндексируются все файлы в этой директории и во всех вложенных. Изменения в других директориях так и останутся без индексации.
      li git add :/ - индексация всех файлов в любой директории, вложенной в базовую (там где расположена директория .git), в том числе и в базовой. (git add -A и git add --all - аналогичны этой команде)

  +main-card('git reset', '', list = true)
    p.
      отменяет индексацию.
      Разновидности git reset:
    ul
      li git reset --hard удаляет все сделанные изменения и возвращает все к последнему коммиту.
      li git reset --soft возвращает к последнему коммиту, но не удаляет сделанные изменения.
      li git reset номерКоммита (например git reset 9e5e6a4) возвращает к соответствующему коммиту, а изменения сделанные после него сохраняются, но остаются непроиндексированные.
      li git reset номерКоммита --hard - удалит все изменения после данного коммита. Если вы удалили полностью все коммиты и локально и удаленно, то вернуться к старым коммитам еще можно. git log не покажет историю коммитов уже. А git reflog покажет. Нужно выбрать нужный коммит и сделать reset на его порядковый номер, например git reset --hard HEAD@{5}.
        
  +main-card('git log', 'выводит список коммитов с полным их номером названием и указанием авторства и даты. git log --pretty=oneline выведет только номера коммитов и их названия')
  +main-card('git reflog', 'выдает список всех коммитов с непосредственным номером коммита и его порядковым номер (например HEAD@{5})')
  +main-card('git commit', '', list = true)
    p.
      выполняет коммит изменений. git commit -m "названиеКоммита" - сделать коммит проиндексированных файлов.
      Разновидности git commit:
    ul
      li git commit -m "названиеКоммита" - сделать коммит проиндексироваанных файлов.
      li git commit -a -m "названиеКоммита" - индексирует файлы и коммитит (позволяет обойтись без git add !НО не индексирует новые созданные файлы, а только измененные).
      li git commit --amend -m "новоеНазваниеКоммита" - переименовать последний сделанный коммит
  +main-card('git show', 'git show номерКоммита (например - git show 9e5e6a4) покажет какие изменения были внесены в этом коммите')
  +main-card('git branch', '', list = true)
    p.
      покажет все созданные ветки с указанием активной ветки.
      Разновидности git branch:
    ul
      li git branch названиеНовойВетки - создает новую ветку.
      li git branch -m новоеНазваниеТекущейВетки - смена названия ветки.
      li git branch -d названиеВетки - удаление ветки, при этом необходимо находиться на любой другой ветке, чтобы удаляемая не была текущей.
      
  +main-card('git grep', 'git grep словоДляПоиска - ищет указанное слово/фрагмент в проекте')
  +main-card('git checkout', '', list = true)
    p.
      git checkout названиеВетки - переключает на указанную ветку. 
      Разновидности git checkout:
    ul
      li git checkout -b названиеВетки - создает вету с указанным именем и сразу переходит в нее
  +main-card('git pull', 'подтягивает изменения с удаленного репозитория. Находясь на нужной ветке подтянет то, чего нет с удаленной такой же ветки. Изменения отобразятся только в соответствующих ветках. git pull origin названиеВетки - подтянет изменения с указанной удаленной ветки в ту локальную, в которой вы сейчас находитесь')
  +main-card('git remote', 'git remote -v - покажет какой репозиторий привязан к проекту')
  +main-card('git revert', '', list = true)
    p.
      Отменяет проведенные изменения в конкретном коммите. При этом создает новый обычный коммит с обращенными назад изменениями указанного коммита. git revert номерКоммита (git revert 9e5e6a4) - найдет коммит и обратит его изменения. Но может возникнуть конфликт изменений, если обращенные изменения уже были модифицированы после коммита, к которому был применен revert.
      Разновидности git revert:
    ul
      li git revert --abort - отменяет команду revert
  +main-card('git push', '', list = true)
    p.
      заливает все изменения со всех локальных веток в удаленный репозиторий. Ветки, созданные локально, но не существующие в репозитории, будут там автоматически созданы. Если это делаете первый раз в новом проекте, то скорее всего терминал вам выдаст сообщение об ошибке с предложением команды git push --set-upstream origin названиеВетки. Необходимо ее выполнить один раз, чтобы связать удаленный репозиторий с вашим проектом. Дальше можно будет уже использовать только git push. Если на удаленном репозитории появились изменения, которых у вас нет локально, то при попытке пуша возникнет ошибка-предупреждение. Она предлагает вам подтянуть новые изменения через git pull, а уже потом выполнить git push. To https://github.com/VasilchenkoSergei/gitknow.git
      ! [rejected] master -> master (fetch first)
      error: failed to push some refs to 'https://github.com/VasilchenkoSergei/gitknow.git'hint: Updates were rejected because the remote contains work that you do
      hint: not have locally. This is usually caused by another repository pushing
      hint: to the same ref. You may want to first integrate the remote changes
      hint: (e.g., 'git pull ...') before pushing again.
      hint: See the 'Note about fast-forwards' in 'git push --help' for details.
      Разновидности git push:
    ul
      li git push --force(или git push -f) - заливает на удаленный репозиторий в любом случае (но при этом нужно убедиться, что вы не затрете изменения, которые кто-то внес до вашего пуша)
  +main-card('git merge', '', list = true)
    p.
      выполняет слияние одной ветки в другую. git merge названиеВетки (например git merge develop) - находясь на любой другой ветке, вы будете вливать ветку develop в ту, на которой находитесь.
      Разновидности git merge:
    ul
      li git merge --abort - отменяет слияние веток при возникшем конфликте (не работает если слияние прошло успешно)